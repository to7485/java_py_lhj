컬렉션 -> List활용

어차피 리스트에 들어가있는 내용에 대해서 전부다 출력, 조건을 맞추거나, 처리
반복문을 사용한다. -> 이것조차 너무 길어

stream과 화살표함수(람다식)

람다식(lambda Expression)
익명 함수를 만들기 위한 표현식을 말한다.

js는 함수형 프로그래밍 방식 -> 함수를 만들어서 해결하는게 가능하다.
java는 객체지향형 프로그래밍 방식 -> 클래스를 만들고 객체를 만들어서 메서드를 호출

int add( int x, int y){
    return x +y;
}

(int x , int y) -> {   return x + y; }

매개변수가 2개일 때 자료형 생략 가능하다.

(x , y) -> {return x + y;}

중괄호와 return은 같이 생략이 가능하다.

(x , y) -> x + y;

매개변수가 하나일때는 소괄호 생략이 가능하다.

(String str) -> {System.out.println(str);}

str -> {System.out.println(str);}

함수형 인터페이스
java에서 인터페이스를 사용하려면 구현체를 만들어서 사용을 해야 한다.
람다식을 사용하면 익명클래스조차 만들지 않아도 된다.

1. 두 개의 int값을 받아서 int결과를 반환하는 IntCalculator 함수형 인터페이스 만들기- 메서드 이름 calc
- 매개변수 이름 x,y

Main클래스에 세 가지 람다식을 만든다.
add : 두 수를 더하는 람다식
sub : 두 수를 빼는 람다식
mul : 두 수를 곱하는 람다식

위 람다식을 이용해 다음 값을 출력한다.
add.calc(10,5);
sub.calc(10,5);
mul.calc(10,5);

람다식을 만드려고 할 때마다 함수형 인터페이스를 만들어야 하나?

java.util.function 패키지
- 대부분의 메서드는 타입이 비슷하다
- 매개변수의 개수는 0 또는 1이거나 2개인 경우가 대다수이다.
- 반환값은 없거나 1개이다.
- 제네릭으로 정의하면 매개변수나 반환타입이 달라도 문제가 되지 않는다.
- 자바가 제공하는 함수형 인터페이스가 있다.

인터페이스	추상메서드	-> 람다식 만듦
Supplier		T get()
Consumer	   	void accept(T t)
Function<T,R>	R apply(T t)
Predicate	 	boolean test(T t)

BiConsumer<T,U>	void accept (T t, U u)
BiPredicate<T,U>	boolean test(T t, U u)
BiFunction<T,U,R>	R apply(T t,U u);

메서드 축약
람다가 하는 일이 이미 존재하는 메서드를 그냥 호출하는 일이라면
메서드 참조 연산자(::)를 사용하여 더 짧게 쓸 수 있다.

stream
List(ArrayList)
사용자와 서버간에 데이터를 주고받을 때 특정 조건에 따라 필터링을 하려면 복잡한 과정을 거쳐야 한다.

for문을 사용하면 간단한 처리는 큰 문제가 아니지만 복잡한 처리가 필요하거나
컬렉션의 크기가 커지면 루프문이 성능저하를 일으킬수도 있다.

스트림
컬렉션 데이터를 선언형으로 쉽게 처리할 수 있게 해준다.
복잡한 루프문을 사용하지 않아도 되고 루프문을 중첩해서 사용해야 되는 최악의 경우도 더이상 없어졌다.

배열, 컬렉션에 메서드 여러개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다.
또한 람다식을 이용해서 코드의 양을 줄이고 간결하게 표현할 수 있다.
즉, 배열과 컬렉션을 함수형으로 처리할 수 있다.

스트림의 특징
- 원본을 변경하지 않는다.
- 한 번 사용하고나면, 스트림을 다시 만들어야 한다.
strStream1.sorted().forEach(System.out::println);

strStream1.count(); -> X

스트림의 사용 과정
1. 스트림의 생성
2. 가공하기 : 정렬,개수를 센다, 처리, 필터링등 원하는 결과를 만들어가는 중간작업
3. 결과만들기 : 최종적으로 결과를 만들어내는 작업

15일부터 다른 강사님이 파이썬 ai부분 맡아서 진행해주십니다.
파이썬 기본문법
자바 -> 스프링부트

프로젝트 하실 때 백엔드 프레임워크는 자유롭게 골라서 하셔도 됩니다

ai -> 텐서플로우 이용 (머신러닝, 딥러닝, 트랜스포머...) 논리적인 사고

람다식, 스트림

@CrossOrigin
CORS (Cross-Orign Resource Sharing) 설정을 컨트롤러 단위로 지정하는 어노테이션

브라우저는 출처가 다른 프론트엔드에서 API를 호출하면 보안을 위해 막으려 한다.

@CrossOrigin(originPatterns = "*", allowCredentials = "false")

originPatterns = "*"
모든 출처를 허용하겠다. -> "어느 도메인에서 오든 다 허용하겠다"












